"""Performance optimization utilities for plant integration."""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional
from homeassistant.core import HomeAssistant
from homeassistant.helpers.event import async_track_time_interval
from homeassistant.util import dt as dt_util

_LOGGER = logging.getLogger(__name__)

# Configuration for data retention
DEFAULT_HISTORY_RETENTION_DAYS = 90
MAX_HISTORY_ENTRIES = 1000
CLEANUP_INTERVAL = timedelta(hours=6)


class MemoryManager:
    """Manages memory usage and data cleanup for plant entities."""
    
    def __init__(self, hass: HomeAssistant):\n        self.hass = hass\n        self._cleanup_tasks: Dict[str, Any] = {}\n        self._history_limits: Dict[str, int] = {}\n        \n    async def setup_cleanup_schedules(self) -> None:\n        \"\"\"Setup periodic cleanup schedules for all plant entities.\"\"\"\n        async_track_time_interval(\n            self.hass,\n            self.periodic_cleanup,\n            CLEANUP_INTERVAL\n        )\n        _LOGGER.info(\"Memory management cleanup scheduled every %s\", CLEANUP_INTERVAL)\n    \n    async def periodic_cleanup(self, now: datetime) -> None:\n        \"\"\"Perform periodic cleanup of old data.\"\"\"\n        try:\n            cleaned_entities = 0\n            cleaned_records = 0\n            \n            # Clean up plant history data\n            for domain_data in self.hass.data.get(\"plant\", {}).values():\n                if \"plant\" in domain_data:\n                    plant = domain_data[\"plant\"]\n                    records_cleaned = await self._cleanup_plant_history(plant)\n                    if records_cleaned > 0:\n                        cleaned_entities += 1\n                        cleaned_records += records_cleaned\n            \n            if cleaned_entities > 0:\n                _LOGGER.info(\n                    \"Memory cleanup completed: %d entities, %d records removed\",\n                    cleaned_entities, cleaned_records\n                )\n                \n        except Exception as e:\n            _LOGGER.error(\"Error during periodic cleanup: %s\", e)\n    \n    async def _cleanup_plant_history(self, plant) -> int:\n        \"\"\"Clean up old history data for a plant entity.\"\"\"\n        records_removed = 0\n        cutoff_date = dt_util.utcnow() - timedelta(days=DEFAULT_HISTORY_RETENTION_DAYS)\n        \n        try:\n            # Clean health history\n            if hasattr(plant, '_attr_extra_state_attributes'):\n                attrs = plant._attr_extra_state_attributes\n                if 'health_history' in attrs:\n                    original_count = len(attrs['health_history'])\n                    attrs['health_history'] = [\n                        entry for entry in attrs['health_history']\n                        if self._is_entry_recent(entry, cutoff_date)\n                    ]\n                    # Also limit by count\n                    if len(attrs['health_history']) > MAX_HISTORY_ENTRIES:\n                        attrs['health_history'] = attrs['health_history'][-MAX_HISTORY_ENTRIES:]\n                    \n                    records_removed += original_count - len(attrs['health_history'])\n            \n            # Clean location history if available\n            if hasattr(plant, 'location_history') and hasattr(plant.location_history, '_history'):\n                location_history = getattr(plant.location_history, '_history', [])\n                if isinstance(location_history, list):\n                    original_count = len(location_history)\n                    recent_history = [\n                        entry for entry in location_history\n                        if self._is_entry_recent(entry, cutoff_date)\n                    ]\n                    if len(recent_history) > MAX_HISTORY_ENTRIES:\n                        recent_history = recent_history[-MAX_HISTORY_ENTRIES:]\n                    \n                    # Update the history\n                    plant.location_history._history = recent_history\n                    records_removed += original_count - len(recent_history)\n            \n            return records_removed\n            \n        except Exception as e:\n            _LOGGER.warning(\"Error cleaning plant history for %s: %s\", getattr(plant, 'entity_id', 'unknown'), e)\n            return 0\n    \n    def _is_entry_recent(self, entry: Any, cutoff_date: datetime) -> bool:\n        \"\"\"Check if a history entry is recent enough to keep.\"\"\"\n        try:\n            if isinstance(entry, dict):\n                if 'timestamp' in entry:\n                    entry_time = datetime.fromisoformat(entry['timestamp'].replace('Z', '+00:00'))\n                    return entry_time > cutoff_date\n                elif 'time' in entry:\n                    entry_time = datetime.fromisoformat(entry['time'].replace('Z', '+00:00'))\n                    return entry_time > cutoff_date\n            return True  # Keep if we can't determine age\n        except (ValueError, AttributeError, TypeError):\n            return True  # Keep if parsing fails\n    \n    def set_history_limit(self, entity_id: str, limit: int) -> None:\n        \"\"\"Set custom history limit for specific entity.\"\"\"\n        self._history_limits[entity_id] = limit\n    \n    def get_history_limit(self, entity_id: str) -> int:\n        \"\"\"Get history limit for entity.\"\"\"\n        return self._history_limits.get(entity_id, MAX_HISTORY_ENTRIES)\n\n\nclass OptimizedSensorManager:\n    \"\"\"Optimized sensor management to reduce database load.\"\"\"\n    \n    def __init__(self, hass: HomeAssistant):\n        self.hass = hass\n        self._virtual_sensors: Dict[str, Any] = {}\n        self._update_batches: Dict[str, List[Any]] = {}\n        \n    def register_virtual_sensor(self, sensor_id: str, sensor) -> None:\n        \"\"\"Register a virtual sensor that doesn't persist to database.\"\"\"\n        self._virtual_sensors[sensor_id] = sensor\n        _LOGGER.debug(\"Registered virtual sensor: %s\", sensor_id)\n    \n    async def batch_update_sensors(self, sensors: List[Any]) -> None:\n        \"\"\"Batch update multiple sensors to reduce database writes.\"\"\"\n        if not sensors:\n            return\n            \n        try:\n            # Group sensors by update frequency\n            high_freq = []\n            low_freq = []\n            \n            for sensor in sensors:\n                if hasattr(sensor, '_update_frequency'):\n                    if sensor._update_frequency == 'high':\n                        high_freq.append(sensor)\n                    else:\n                        low_freq.append(sensor)\n                else:\n                    low_freq.append(sensor)\n            \n            # Update high frequency sensors immediately\n            for sensor in high_freq:\n                if hasattr(sensor, 'async_write_ha_state'):\n                    sensor.async_write_ha_state()\n            \n            # Batch low frequency sensors\n            if low_freq:\n                await self._batch_write_states(low_freq)\n                \n        except Exception as e:\n            _LOGGER.error(\"Error in batch sensor update: %s\", e)\n    \n    async def _batch_write_states(self, sensors: List[Any]) -> None:\n        \"\"\"Write multiple sensor states in batch.\"\"\"\n        tasks = []\n        for sensor in sensors:\n            if hasattr(sensor, 'async_write_ha_state'):\n                tasks.append(asyncio.create_task(\n                    asyncio.to_thread(sensor.async_write_ha_state)\n                ))\n        \n        if tasks:\n            await asyncio.gather(*tasks, return_exceptions=True)\n\n\nclass DatabaseOptimizer:\n    \"\"\"Optimize database operations for plant integration.\"\"\"\n    \n    def __init__(self, hass: HomeAssistant):\n        self.hass = hass\n        \n    async def optimize_plant_queries(self) -> None:\n        \"\"\"Optimize database queries for plant data.\"\"\"\n        try:\n            # Implementation would depend on specific database optimization needs\n            # This is a placeholder for future enhancements\n            _LOGGER.debug(\"Database optimization completed\")\n        except Exception as e:\n            _LOGGER.error(\"Database optimization failed: %s\", e)\n    \n    def should_persist_sensor(self, sensor) -> bool:\n        \"\"\"Determine if sensor data should be persisted to database.\"\"\"\n        # Check if sensor is marked as virtual or reference-only\n        if hasattr(sensor, '_virtual') and sensor._virtual:\n            return False\n            \n        # Check if sensor references external data\n        if hasattr(sensor, '_external_reference') and sensor._external_reference:\n            return False\n            \n        return True\n\n\nasync def setup_performance_monitoring(hass: HomeAssistant) -> None:\n    \"\"\"Setup performance monitoring and optimization.\"\"\"\n    memory_manager = MemoryManager(hass)\n    await memory_manager.setup_cleanup_schedules()\n    \n    sensor_manager = OptimizedSensorManager(hass)\n    \n    # Store managers in hass data for access by other components\n    if \"plant_performance\" not in hass.data:\n        hass.data[\"plant_performance\"] = {}\n    \n    hass.data[\"plant_performance\"][\"memory_manager\"] = memory_manager\n    hass.data[\"plant_performance\"][\"sensor_manager\"] = sensor_manager\n    \n    _LOGGER.info(\"Plant performance monitoring initialized\")